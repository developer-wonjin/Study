# 부분범위처리
슬라이드5-46

```sql
-- 10,000,000 (1000만건)의 큰 테이블
select count(*) from big_table;

-- case1
-- TFS , 부분범위처리
-- 정렬없이  0.37s
select * from big_table;

-- case2
-- 기본 옵티마이저모드가 'all_rows' 이므로 전체데이터를 fetch한다는 전제로 전체데이터를 디스크I/O해옴. 전체범위처리 
-- 전체범위처리로 TFS 디스크I/O진행. 이후 부분범위처리로 클라이언트로 전송
-- 엄청느림. 수행시간 25s
select * from big_table order by owner;

-- case3
-- x1인덱스(owner+created)가 있음에도 전체데이터를 fetch하는 전제인 all_rows를 위해 클러스터링팩터가 좋은 pk를 이용하다. 
-- 엄청느림. 수행시간 30S
select /*+ index(X)                 */ * from big_table X order by owner;

-- case4
-- 인덱스를 통한 부분범위처리
-- 엄청 빠름. 수행시간 0.40s
select /*+ index(X) first_rows */ * from big_table X order by owner;
select /*+ index(X (owner,created)) */ * from big_table X order by owner;
select /*+ index(X big_table_x1)    */ * from big_table X order by owner;

```


# TOP N 쿼리
## TOP N STOPKEY 
```sql
select *
from (
    select /*+ FIRST_ROWS */ rownum no, a.*
    from
    (
        -- SQL Body 시작
        select owner, object_name 
        from big_table
        where owner = 'SYS'
        and created > TO_DATE('20170126135300','YYYYMMDDHH24MISS')
        order by created
        -- SQL Body 끝
    ) a
    where rownum <= (:page * 10)
)
where no >= (:page - 1) * 10 + 1
;
```

## TOP N SORT알고리즘
```sql
select * 
from (
    select /*+  */ rownum no, a.*
    from
    (
        -- SQL Body 시작
        select owner, object_name 
        from big_table
        where owner = 'SYS'
        and created > TO_DATE('20170126135300','YYYYMMDDHH24MISS')
        order by created
        -- SQL Body 끝
    ) a
    where rownum <= (:page * 10)
)
where no >= (:page - 1) * 10 + 1
;
```

## TOP N 쿼리가 아닐 떄
```sql
select *
from (
    select rownum no, a.*
    from
    (
        -- SQL Body 시작
        select owner, object_name 
        from big_table
        where owner = 'SYS'
        and created > TO_DATE('20170126135300','YYYYMMDDHH24MISS')
        order by created
        -- SQL Body 끝
    ) a
    
    -- rownum에 대한 where문 제거

)
where no between (:page * 10) and (:page - 1) * 10 + 1
;
```