```sql
SELECT sql_id, child_number, sql_text, last_active_time 
from v$sql
WHERE sql_text like 'select  %';




select  /*+ gather_plan_statistics */ * from emp;
select *from table(dbms_xplan.display_cursor(null, null, 'allstats last'));

set serveroutput off;

-- 레코드가 많은 테이블을 조회할 떄 주의사항

select  /*+ gather_plan_statistics */ * from small_table;
--위 쿼리의 모든 레코드들을 fetch받아오고 나서 아래쿼리실행해야함
select *from table(dbms_xplan.display_cursor(null, null, 'allstats last'));



SQL> SELECT dummy FROM dual;

Execution Plan
----------------------------------------------------------
Plan hash value: 272002086

--------------------------------------------------------------------------
| Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |      |     1 |     2 |     2   (0)| 00:00:01 |
|   1 |  TABLE ACCESS FULL| DUAL |     1 |     2 |     2   (0)| 00:00:01 |
--------------------------------------------------------------------------


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
          3  consistent gets
          0  physical reads
          0  redo size
        371  bytes sent via SQL*Net to client
        344  bytes received via SQL*Net from client
          2  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
          1  rows processed

==> 메모리에서 I/O해옴.
==> WAS, sqlClient는 conn이 살아있는지 확인하기 위해 dual테이블을 몇초단위로 조회한다.   
DUAL 테이블의 블록이 소속된 해시체인의 다른 블록들에게 경합문제를 발생시킬 수 있다.


-- SELECT절에 컬럼/ * 을 명시하면
-- 실제 값을 읽기 때문에 I/O 발생함.
select dummy from dual
select * from dual

-- consistent gets: 0, I/O 발생안함.
-- fast dual 실제로 데이터 안 읽음
-- I/O가 발생하지 않음 그러나 DBCall이 발생하는 것이기에 너무 dual을 남발하지 말것.
-- 개발언어단에서 가능하면 DBCall을 줄여라(날짜, 형변환)
select 1 from dual
select sysdate from dual

-- 
여러프로세스들이 사용하는 가장많이 접근하는 블록 = Hot Block
HotBlock이 있는 대표적인 예(가장많이 조회,변경이 일어나는 블록)
  1. 일련번호/입력일시 컬럼에 인덱스가 있고 그 인덱스 리프블럭 중 맨 오른쪽블록(Right-Growing-Index)
  2. dual테이블
  3. 입력일시/변경일시 컬럼이 있는 테이블
  4. 채번테이블
==> 디스크I/O가 없더라도 메모리상에서 프로세스간 경합이 발생하여 성능저하가 발생할 수 있음.  
 
해시파티션(Right-Growing-Index의 해결책)
- 인덱스를 파티셔닝함.
- 세그먼트를 여러개만듬
- 예를들어, 인덱스를 4개의 서브파티션으로 나누면 동시엑세스가 4개의 블록으로 분산됨





SELECT  종목영문심볼, 거래일시, SUBSTR(거래일시,9,6) 거래시각, 현재환율가격
  FROM  실시간환율 a
 WHERE  종목영문심볼 = 'USDKRWCOMP' 
   AND  해외은행코드 = 'EUAM'
   AND  SUBSTR(거래일시,1,8) = :trdDd    --> 20190505 입력
   AND  SUBSTR(거래일시,9,6) >= '090000'
   AND  SUBSTR(거래일시,9,6) <= '150000';
   
SELECT /*+ INDEX(실시간환율) */  종목영문심볼, 거래일시, SUBSTR(거래일시,9,6) 거래시각, 현재환율가격
  FROM  실시간환율 a
 WHERE  종목영문심볼 = 'USDKRWCOMP' 
   AND  해외은행코드 = 'EUAM'
   AND  SUBSTR(거래일시,1,8) = :trdDd    --> 20190505 입력
   AND  SUBSTR(거래일시,9,6) >= '090000'
   AND  SUBSTR(거래일시,9,6) <= '150000';
   
SELECT * FROM table(dbms_xplan.display_cursor(null, null, 'allstats last'));

SELECT /*+ gather_plan_statistics */  종목영문심볼, 거래일시, SUBSTR(거래일시,9,6) 거래시각, 현재환율가격
  FROM  실시간환율 a
 WHERE  종목영문심볼 = 'USDKRWCOMP' 
   AND  해외은행코드 = 'EUAM'
   AND  거래일시 BETWEEN :trdDd || '090000' AND :trdDd || '150000';
   
SELECT * FROM table(dbms_xplan.display_cursor(null, null, 'allstats last'));
```