정답 : 3 

 

해설 : 주문상품_X1 인덱스가 「주문일자 + 상품코드」 순으로 구성돼 있고, 선두 컬럼인 주문일자가 부등호 조건이므로 상품코드 조건절은 필터 조건일 수밖에 없습니다. 따라서 상품코드 조건절을 어떻게 구현하든 성능에는 차이가 없습니다.  

상품코드가 필터 조건인 상황에서 ③번처럼 CONCATENATION 방식으로 실행하면, 같은 구간(주문일자 조건을 만족하는 구간)의 데이터를 반복해서 읽음으로써 성능은 오히려 느려집니다. 

 

지난 주 문제에선 CONCATENATION 방식으로 처리하는 것이 최적인 반면, 지금은 정반대입니다. 이처럼 SQL 튜닝은 상황(인덱스 구성, 조건절 유형, 데이터 분포, 수행빈도, 애플리케이션 특성 등)에 따라 최적 해법이 다를 수 있음을 꼭 기억하시기 바랍니다. 

참고로, 타 카페의 아래 질문글을 보고 생각해 낸 튜닝워크숍이었습니다. ^^

 

https://cafe.naver.com/sqlpd/32549

 
핵심노트 1권 
83페이지 
48번 문제와 관련있습니다.
참여해 주셔서 감사합니다.