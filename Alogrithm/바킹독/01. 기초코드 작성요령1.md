

# 수

| --    | --          |      |                   |
| ----- | ----------- | ---- | ----------------- |
| 1만   | 10,000      | 10^4 | O(n^2)을 허용안함 |
| 100만 | 1,000,000   | 10^6 |                   |
| 1억   | 100,000,000 | 10^8 |                   |
|       |             |      |                   |

# 시간복잡도

| N의 크기                               | 허용 시간복잡도 |
| -------------------------------------- | --------------- |
| N <= 11                                | O(N!)           |
| N <= 25                                | O(2^N)          |
| N <= 100                               | O(N^4)          |
| N <= 500                               | O(N^3)          |
| N <= 3000                              | O(N^2 * logN)   |
| **N <= 5,000**                         | **O(N^2)**      |
| N <= 1,000,000(1백만)                  | O(N logN)       |
| **N <= 100,000,000 (1억번 = 0이 8개)** | **O(N)**        |

- 내 알고리즘이 `허용 시간복잡도` 를 통과하는지 체크해야함.







## 연산횟수 세는 방법

변수선언및 초기화

비교연산

산술연산

```c
int func1(int arr[], int n) {
	int cnt = 0;//선언및 초기화 1번
    
    // 아래 int i 변수선언및 초기화 1번
	for (int i = 0; i < n; i++) {	// i와 n 비교, i증가 산술연산        ---- 총 2번
		if (arr[i] % 5 == 0) cnt++; // i%5 산술연산, 0과 비교연산, cnt 증감연산 ---- 총 3번
	}
	return cnt; // cnt 반환할 때 1번
}
// 총 1 + 1 + n*(2+3) + 1 = 5n + 3 
```

# 공간복잡도

예) 크기 N짜리 2차원배열은 공간복잡도 O(N^2) 

**512 MB = 1.2억개 int 배열 선언가능**(int 는 4byte)

# 정수자료형

```c
//unsigned char
00001001   // 2^3 + 2^0 = 9
10000011   // 2^7 + 2^1 + 2^0 = 131
    
//signed char(최상위 비트는 - 값으로 계산해야함)
00001001   // 2^3 + 2^0 = 9
10000011   // -2^7 + 2^1 + 2^0 = -125
```

| 타입      | 바이트 | 숫자범위                                                     | 유효숫자                                                     |
| --------- | ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| char      | 1byte  | -2^7  ~ 2^7 - 1  (-128 ~ **127**)<br>      0 ~ 2^8 - 1  (0 ~ 255) - UNSIGNED 경우 |                                                              |
| short     | 2byte  | -2^15  ~ 2^15 -1  (-32768 ~ **32767**)                       |                                                              |
| int       | 4byte  | -2^31  ~ 2^31 - 1  (-21억 ~ **21억**)<br>                    | 10억은 10자리 자릿수(0이 9개를 차지)                         |
| long long | 8byte  | ~ 2^63 - 1 까지 표현                                         | **최대 19자리** (0이 18개 차지)<br>피보나치 80번쨰 수를 구할 때 |

# Integer Overflow

```c
int main(void){
    int a = 2000000000 * 2; //2,000,000,000 * 2 는 21억을 넘음
    cout << a;// -294967296
}
```

```c
int a = 1,000,000,000; // a에 10을 곱하면 100억 단위가 되버려 overflow발생
```



case1)

```c
void func1(){
	//s가 127까지는 괜춘. 이후 s++ 로 s가 128이 되는 순간 -128인 overflow값이 되며 무한루프에 빠짐
    //따라서 s를 int로 변경해야함
    for(char s = 0; s < 128; s++){
        cout << "hi";
    }
}
```

case2)

```c
int  func2(){
    int r = 1;
    for(int i = 1; i <= 50; i++){
        r = r * i % 61;
    }
    return r;
}
```

case3)

```c
//a의 자료형을 long long으로 변경하거나
//a= 10 * a % mode 라인에서 숫자 10을 10LL 으로 바꾸거나 (longlong)10으로 변경하면 됨.
int func3(){
    int a = 10;
    int mod = 1000000007;
    for(int i = 0; i < 10; i++){
        a = 10 * a % mod;
    }
    return a;
}
```

- unsigned long long을 넘어버리는 숫자를 저장해야한다면 String으로 연산하는것이 좋다.(파이썬이 더 편리함)

# 실수 자료형

| --            | sign | exponent | fraction | 유효숫자 |
| ------------- | ---- | -------- | -------- | -------- |
| float(4byte)  | 1bit | 8bit     | 23bit    | 6bit     |
| double(8byte) | 1bit | 11bit    | 52bit    | 15bit    |



## 실수 데이터 저장하기1step( 이진수로 표현하기 )

```c
3 = 2^1 + 2^0 = 11(2)
3.75 = 2^1 + 2^0 + 2^(-1) + 2^(-2) = 11.11(2)
1/3  = 2^(-2) + 2^(-4) +2^(-6) +2^(-8) + .... = 0.01010101....(2)
```



## 실수 데이터 저장하기 2step( 이진수 표현의 정규화)

```c
3561.234 = 3.561234E3
11101.001(2) = 1.1101001(2) * 2^4
-6.75 = -1.1011(2) * 2^2
```



## 실수 데이터 저장하기 3step(정규화를 한 이진수를 bit로 저장할 때)

```c
//-6.75 = -1.1011(2) * 2^2

signField: 1(MSB)
exponentField: 10000001 //지수2 에 127을 더한 129를 이진수로 변환하여 저장(127은 8bit의 모든 음수/양수 지수를 양수로 만들어줌)
fractionField: 10110000000000000000000
    
//결과(4byte)
11000000 11011000 00000000 00000000
```

 

## 실수의 중요한 특징(반드시 숙지)

### 1. 실수의 저장/연산 과정에서 반드시 오차발생

```c
int main(void){
    if(0.1+0.1+0.1 == 0.3) cout << "true";
    else cout << "no no...";
}
```

- 애초에 0.1 은 2진수 값으로 정확히 표현되지 않아 0.1 자체가 잘린 값이 저장됨
- 위 표현중 유효숫자 15bit 까지는 허용한다는 말의 의미

| --            | sign | exponent | fraction | 유효숫자 |
| ------------- | ---- | -------- | -------- | -------- |
| float(4byte)  | 1bit | 8bit     | 23bit    | 6bit     |
| double(8byte) | 1bit | 11bit    | 52bit    | 15bit    |

```c
double x = 1; 
x == 1 + 0.000000000000001;//false 
x == 1 - 0.000000000000001;//false 즉, 15자리까지 유효한 숫자자리로 봄. 값의 변화를 인지함
```



### 2. double에 longlong 값을 함부로 담으면 안된다.

```c
int main(void){
    //유효숫자가 15자리인 double에 19자리인 long long의 값들을 구별할 능력이 없다.
    double a = 1000000000000000001;//우항 19자리 longlong의 최대 자릿수
    double b = 1000000000000000000;
    a == b //true
    //두 값을 구분하지 못하는 에러를 낸다
}
```

- double의 유효숫자는 15라서 19자리데이터를 구분 못함
- 단, int를 double에 담아도 괜춘

### 3. 실수를 비교할 때는 등호를 사용하면 안된다.

```c
int main(void){
    double a = 0.1 + 0.1 + 0.1;
    double b = 0.3;
    if(a == b)cout << "same 1\n"; // false값을 갖음
    if(abs(a-b) < 1e-12) cout << "same 2\n";//true
}
```

아주작은 입실론 **1e-12** 를 기억하자







