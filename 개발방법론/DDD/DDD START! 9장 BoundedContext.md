# DDD START! 9장 BoundedContext

# 1. 한 도메인모델을 여러 서브도메인에서 사용할 경우



## 1.0. 문제상황

- 아래 같이 `회원모델` 로 동일 모델을 사용하면?
  - 각 하위도메인별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워짐

| 서브도메인 | 의미 |
| ---------- | ---- |
| 회원       | 회원 |
| 주문       | 회원 |
| 배송       | 회원 |



## 1.1. 같은 용어 다른 의미

예)  `상품 모델`

| 서브도메인 | 의미                                                         |
| ---------- | ------------------------------------------------------------ |
| 카탈로그   | 상품명, 모델명, 이미지, 가격, 옵션리스트, 상세설명 등의 상품정보 |
| 재고관리   | 물리적 실존하는 상품 (제품번호)                              |
| 주문       | ...                                                          |
| 배송       | ...                                                          |



## 1.2. 같은 대상 다른용어

예) `상품 모델`

| 서브도메인 | 의미 |
| ---------- | ---- |
| 카탈로그   | 상품 |
| 검색       | 문서 |

예) `회원 모델`

| 서브도메인 | 의미       |
| ---------- | ---------- |
| 회원       | 회원       |
| 주문       | 주문자     |
| 배송       | 보내는사람 |



# 2. Bounded Context 통합

## 2.1. RestAPI [직접통합]

- restAPI가 아닌 다른 방식으로도 대체할 수 있는 가능성을 주기 위해 DIP 를 활용한다.
- `도메인영역` 에 위치한 인터페이스는 다음의 두가지 책임을 갖는다
  - 데이터를 가져오는 책임
  - 데이터를 자신의 도메인모델에 맞게끔 변환하는 책임

## 2.2. 비동기메세지 [간접 통합]

- `메세지 시스템` 을 활용하여 `출판 - 구독` 방식
  - 메세지 시스템이 상류에 있냐, 하류에 있냐에 따라 특징이 나뉨
  - 하류에 있을 때 [그림9.16] ==> 비동기(출판+구독)
  - 상류에 있을 떄    ==> 비동기 (RestAPI)

# 3. Bounded Context 간 관계

마치 `서버-클라이언트 관계` 처럼 컨텍스트간 역할을 구분함

## 상류 (1)

- API 제공자
- 공급자

## 하류 (1 또는 多)

- API 호출 주체
- 사용자
- 고객
- 완충지대 필요(데이터를 가져오는 책임 + 데이터를 자신에 맞게 바인딩하는 책임)
  - API제공자인 상류의 도메인모델에 맞춰 API데이터가 응답되니까 하류 자신의 모델에 맞게끔 변환필요

## 공개호스트서비스 (OHS)

하류가 여럿일 때는 상류는 `일관성` 있는 `단일 API` 를 제공하는 방식을 사용한다.

# 10장. 이벤트

# 1. 강결합 문제상황

## 1.1주문도메인에서 결제도메인의 서비스를 호출하는데 문제상황

- 결제도메인(외부서비스)가 정상처리가 되지 않고 익셉션이 발생할 때
- 결제도메인의 응답을 기다려하는 대기 성능문제

## 1.2. 주문도메인객체에 `RefundService`라는 도메인서비스를 전달하는 문제

- `NotifierService`가 추후에 추가되면 기능이 덕지덕지 불어남
- 트랜잭션처리가 더 복잡

# 2. 해결책 => 비동기, 이벤트

- 이벤트에는 작업을 수행하는데 필요한 최소한의 데이터가 필요하다
- 만약 데이터가 부족할 경우

>이 핸들러가 같은 VM에서 동작하고 있다면 다음과 같이 주문데이터를 로딩해서 배송지 정보를 추출해야한다

```java
public class ShippingInfoChangedHandler implemenet EventHandler<ShippingInfoChangedEvent>{
    ...
    @Override
    public void handle(ShippingInfoChangedEvent evt){
        //같은 VM에서만 이벤트가 전달되는 것?
        Order order = orderRepository.findById(evt.getOrderNo());
        shippingInfoSynchronizer.sync(order.getNumber(), order.getShippingInfo());
    }
}
```



